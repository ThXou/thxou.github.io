<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | ThXou]]></title>
  <link href="http://www.thxou.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://www.thxou.com/"/>
  <updated>2016-10-12T22:11:16+02:00</updated>
  <id>http://www.thxou.com/</id>
  <author>
    <name><![CDATA[Luis Cardenas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CocoaPods: Como Integrarlo en Nuestros Proyectos]]></title>
    <link href="http://www.thxou.com/2014/06/26/cocoapods-como-integrarlo-en-nuestros-proyectos/"/>
    <updated>2014-06-26T20:10:51+02:00</updated>
    <id>http://www.thxou.com/2014/06/26/cocoapods-como-integrarlo-en-nuestros-proyectos</id>
    <content type="html"><![CDATA[<p><div style="text-align:center;"><img src="http://www.thxou.com/wp-content/uploads/2014/06/cocoapods.png" /></div></p>




<p>CocoaPods es un herramienta de gestión de dependencias. Normalmente cuando usamos librerías de terceros, debemos copiar todos los ficheros necesarios de la librería directamente dentro de nuestro proyecto para poder utilizarla. Este modo de usar librerías tiene algunos inconvenientes, como por ejemplo que se hace difícil mantener la librería actualizada de nuevos cambios, teniendo que hacer el proceso manualmente cada vez que queramos actualizarla.</p>




<p>CocoaPods soluciona este problema proveyendo un sistema centralizado donde conviven todas las librerías, las trae a tu proyecto a petición y mantiene el entorno adecuado para el correcto control de las dependencias que puedan haber entre librerías y para que tu proyecto pueda compilar sin ningún problema.</p>


<!--more-->




<h2>Instalación</h2>




<p>Instalar CocoaPods y ponerse a trabajar con él es sumamente sencillo. Corre bajo Ruby, así que primero tendrías que instalar Ruby antes de CocoaPods. No obstante, si la versión de tu sistema operativo es de OS X Lion en adelante no necesitas instalar Ruby ya que este viene instalada de forma predeterminada. Aún así, es recomendable actualizar el administrador de paquetes RubyGems a la última versión. Para ello abre una ventana del Terminal y escribe el siguiente comando:</p>


<p>{% codeblock %}
sudo gem update &ndash;system
{% endcodeblock %}</p>

<p>Una vez completado el proceso ya podemos instalar CocoaPods con el siguiente comando:</p>


<p>{% codeblock %}
sudo gem install cocoapods
{% endcodeblock %}</p>

<p>Ya casi estamos listos. Por último tenemos que ejecutar el siguiente comando. Lo que hará es copiar a tu ordenador el <a href="https://github.com/CocoaPods/Specs">repositorio de especificaciones</a> (Veremos esto de las especificaciones más adelante cuando creemos nuestra propia librería y veamos el proceso de subirlo al repositorio de CocoaPods), concretamente a la carpeta <code>~/.cocoapods/repos</code>. Si ya existe, simplemente actualizará el contenido de la carpeta:</p>


<p>{% codeblock %}
pod setup
{% endcodeblock %}</p>

<p>Si todo ha ido bien, entonces felicitate por el trabajo conseguido. Ya tienes CocoaPods instalado y listo para usarse.</p>




<h2>Integrando CocoaPods en nuestro proyecto</h2>




<p>Para esto vamos a crear un proyecto sencillo. Abre Xcode y ve al menú <code>File/New/Project…</code>, y elige la plantilla <code>Single View Application</code>. Ponle por nombre <code>CocoaPodsTest</code> y guardalo donde quieras, especialmente en un lugar fácil de acceder.</p>




<p>Una vez creado el proyecto, procede a cerrarlo. Si, aunque suene raro. Ya te explico el porque dentro de nada.</p>




<p>Abre una ventana del terminal y navega hacia el directorio del proyecto. Si lo guardaste en el escritorio, el comando lucirá algo así:</p>


<p>{% codeblock %}
cd ~/Desktop/CocoaPodsTest
{% endcodeblock %}</p>

<p>Luego ejecuta el siguiente comando (asegúrate de estar dentro del directorio del proyecto):</p>


<p>{% codeblock %}
pod init
{% endcodeblock %}</p>

<p>Este comando va a crear el fichero <code>Podfile</code> de tu proyecto. El fichero Podfile es el lugar donde vas a definir las librerías que usarás dentro de tu proyecto. También puedes definir varios targets y librerías diferentes para cada target. Vamos a editar este fichero para mostrar cómo añadir nuestras librerías. Para esto ábrelo usando tu editor favorito (no uses TextEdit en ningún caso).</p>




<p>Al abrirlo verás algo similar a esto:</p>


<p>{% codeblock lang:objc %}</p>

<h1>Uncomment this line to define a global platform for your project</h1>

<h1>platform :ios, &ldquo;6.0&rdquo;</h1>

<p>target &ldquo;CocoaPodsTest&rdquo; do</p>

<p>end
{% endcodeblock %}</p>

<p>Al crearse el fichero, siempre se crea especificando un target por defecto, en este caso <code>CocoaPodsTest</code>. La línea de arriba que está comentada nos dice a partir de que versión de iOS corre tu proyecto. Si tienes Xcode completamente actualizado, lo normal es que el proyecto que hayas creado al principio, corra a partir de la 7.1, por lo que tendrías que reemplazar esta línea por:</p>


<p>{% codeblock lang:objc %}
platform :ios, &ldquo;7.1&rdquo;
{% endcodeblock %}</p>

<p>Ahora vamos a incluir nuestra primera librería. Para esto añade lo siguiente inmediatamente después de la línea <code>target "CocoaPodsTest" do</code>:</p>


<p>{% codeblock lang:objc %}
pod &lsquo;LCAnimatedMenu&rsquo;, &lsquo;1.0.0&rsquo;
{% endcodeblock %}</p>

<p>De esta manera defines las librerías que deseas incluir en tu proyecto, una en cada línea. En este caso además de la librería, le estás diciendo a CocoaPods que versión en concreto quieres de esa librería. Puedes omitir la versión y CocoaPods incluirá la última versión disponible.</p>


<p>{% blockquote %}
Si quieres saber más acerca de la sintaxis de este fichero y sobre que configuraciones más avanzadas puedes incluir, sigue <a href="http://guides.cocoapods.org/using/the-podfile.html">este enlace</a> hacia la documentación oficial.
{% endblockquote %}</p>

<p>Ahora guarda el fichero y cierra el editor.</p>




<p>El siguiente paso es decirle a CocoaPods que instale las librerias. Para esto escribe el siguiente comando en el Terminal:</p>


<p>{% codeblock %}
pod install
{% endcodeblock %}</p>

<p>Al finalizar el proceso de instalación saldrá un mensaje igual a este:</p>


<p>{% codeblock %}
[!] From now on use <code>CocoaPodsTest.xcworkspace</code>.
{% endcodeblock %}</p>

<p>Si vas a usar CocoaPods de hoy en adelante, este es <strong>el mensaje más importante que tienes que recordar</strong>. Desde ahora, ya no abrirás más el fichero del proyecto para trabajar con él, sino el workspace que crea CocoaPods en el cual conviven todas las librería que vayas a instalar y tu proyecto también. Es por eso que más arriba te dije de cerrar el proyecto.</p>




<p>Abre el fichero <code>CocoaPodsTest.xcworkspace</code> y veamos como usar la librería que acabamos de incluir.</p>




<p>Dentro del workspace verás 2 proyectos, el tuyo y otro llamado Pods. En Pods están incluidas todas las librerías que hayas añadido y otros ficheros que no deberías de tocar jamás, a menos que sepas lo que estás haciendo, claro está. También vas a encontrar el fichero <code>Podfile</code> que editamos anteriormente. Desde ahora, cada vez que quieras añadir una librería nueva, puedes editar el fichero directamente desde Xcode.</p>




<h2>Learn To Fly</h2>




<p>Trabajar con las librerías que hemos añadido es idéntico a como lo hacíamos antes. Abre el fichero <code>ViewController.m</code> e importa la librería:</p>


<p>{% codeblock lang:objc %}</p>

<h1>import &lt;LCAnimatedMenu.h></h1>

<h1>import &lt;LCMenuItem.h></h1>

<p>{% endcodeblock %}</p>

<p>Ahora que has importado las librerías a tu proyecto, hay que usar la API de la librería, exactamente como lo hacías antes. Ahora reemplaza el método <code>ViewDidLoad</code> con el siguiente trozo de código:</p>


<p>{% codeblock lang:objc %}
- (void)viewDidLoad
{
    [super viewDidLoad];</p>

<pre><code>UIImage *itemImage = [UIImage imageNamed:@"item"];
ActionBlock actionBlock = ^(void) {
    NSLog(@"Botón presionado!");
};

LCMenuItem *item1 = [[LCMenuItem alloc] initWithImage:itemImage withActionBlock:actionBlock];
LCMenuItem *item2 = [[LCMenuItem alloc] initWithImage:itemImage withActionBlock:actionBlock];
LCMenuItem *item3 = [[LCMenuItem alloc] initWithImage:itemImage withActionBlock:actionBlock];
LCMenuItem *item4 = [[LCMenuItem alloc] initWithFrame:CGRectZero];

LCAnimatedMenu *menu = [[LCAnimatedMenu alloc] initWithItems:@[item1, item2, item3, item4]];
menu.containerView = self.view;
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>En este código he incluido una imagen que obviamente no estará en el proyecto. Si quieres ver como luce puedes descargarla desde <a href="https://raw.githubusercontent.com/ThXou/LCAnimatedMenu/master/LCAnimatedMenu/Images.xcassets/item.imageset/item@2x.png">este enlace</a> y añadirla a la carpeta de <code>Images.xcassets</code> del proyecto.</p>




<p>Ya hemos terminado!. Ahora compila el proyecto para ver la librería en acción. Tan sencillo como esto.</p>




<h2>Conclusiones</h2>




<p>Tiene sus ventajas usar un administrador de dependencias como CocoaPods, la que más salta a la vista es el hecho de no tener que preocuparte del arrastre de ficheros de librerías con cada actualización, cosa que considero bastante tediosa la verdad, aunque todos sabemos que en realidad no es para tanto. No obstante hay otros beneficios como el hecho de ahorrarnos espacio dentro del proyecto y el hecho de evitarnos la tentación de modificar el código fuente de las librerías.</p>




<p>Con respecto a este último aspecto, en ocasiones me encuentro con que las librerías no se adaptan exactamente a lo que quiero, por lo que en algunos casos sí que deseo poder modificar el código (Puedes enviar una petición al desarrollador de la librería, pero claro, nunca sabes cuanto puede tardar en hacerse realidad tu deseo). Todo va a depender de tus necesidades en momentos específicos. No obstante aunque uses CocoaPods, aún puedes añadir librerías manualmente sin problemas, de modo que yo personalmente recomiendo usarlo.</p>




<p>Por último, en la segunda parte de este tutorial, aprenderemos sobre el proceso de envío de nuestra propia librería al repositorio de especificaciones de CocoaPods. Verás que es un proceso muy sencillo en un tutorial aún más corto que este.</p>




<p>Happy Coding!</p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Migración Sencilla De Modelos en Core Data]]></title>
    <link href="http://www.thxou.com/2013/11/12/migracion-sencilla-de-modelos-en-core-data/"/>
    <updated>2013-11-12T02:21:29+01:00</updated>
    <id>http://www.thxou.com/2013/11/12/migracion-sencilla-de-modelos-en-core-data</id>
    <content type="html"><![CDATA[<p>Probablemente los que ya habéis usado Core Data en vuestras aplicaciones, os habréis encontrado con que cada vez que modificas el modelo de datos, al volver a instalar la app en el simulador o dispositivo, la aplicación genera una excepción y se cierra. En el entorno de desarrollo, la solución inmediata es borrar la aplicación del simulador o dispositivo y volverla a instalar, no obstante esto no nos sirve de cara a actualizar nuestra app que ya está subida a la App Store, por razones obvias.</p>


<h2>El problema!</h2>


<p>Sucede que el sistema de almacenamiento en Core Data solo puede ser abierto por el mismo modelo que se ha usado para crearlo, es por eso que cuando cambias el modelo (añades algún atributo, entidad, etc), el modelo modificado deja de ser igual al modelo que se ha usado para crear el almacenamiento, por lo tanto, son incompatibles y el modelo nuevo resulta no apto para llevar a cabo la tarea.</p>


<p>La solución es llevar a cabo una migración entre versiones del modelo (la anterior y la modificada). Para hacer esta migración, Core Data usa un<strong> modelo de Mapeo</strong> que le permite saber que cambios tiene que realizar para que el nuevo modelo sea capaz de abrir el almacenamiento como lo hacía el modelo anterior.</p>


<p>Poniéndonos ya en materia, existen 2 tipos de migración:<strong> la migración automática</strong>, de la que hablaremos ahora, y <strong>la migración manual</strong>. Estas 2 tan solo difieren en una cosa: El modelo de mapeo usado para hacer la migración. Os paso a explicar más detalladamente el tema.</p>


<!-- more -->


<h2>Migración automática</h2>


<p>También se le conoce como migración ligera. Es el camino fácil para realizar la tarea, y consiste en que Core Data es quien provee el modelo de mapeo a usarse en la migración, hace esto intentando deducir los cambios que se han hecho a través de un análisis en los esquemas de los 2 modelos.</p>


<p>Este tipo de migración requiere que el modelo modificado tan solo haya sufrido sencillos cambios en su estructura. Ahora, que entiende Core Data como &#8220;sencillos cambios&#8221;?. Pues los siguientes:</p>


<ul><li>Añadir o quitar un atributo.</li><li>Cambiar la propiedad <code>optional</code> de los atributos.</li><li>Asignar un valor por defecto a un atributo.</li><li>Renombrar entidades o atributos usando el campo <em>Renaming ID</em>.</li></ul>


<p>Para casos más complejos es necesario usar la migración manual, en ese caso te toca a ti proveer el mapeo para la migración, proceso que se complica un poco, así que lo dejaremos para otra entrada.</p>


<h2>Añadiendo un nuevo modelo</h2>


<p>Vamos con una aplicación práctica para ver mejor como va el tema. Para esto, he creado un proyecto que usa Core Data con un modelo muy sencillo ya definido y que puedes <a href="http://sl.thxou.com/?https://app.box.com/s/2nuh2hgzxq09qtt49t5b">descargar aquí</a>.</p>


<p>Ya que para hacer una migración son imprescindibles 2 versiones de un modelo, vamos a crear otro diferente a la que ya tenemos en el proyecto yendo al menú <strong>Editor &gt; Add Model Version</strong>. Dejemos el nombre por defecto por esta vez y luego clic en <em>Finish</em>. Esto nos creará <em>Notes 2.xcdatamodel</em> y una especie de carpeta contenedora llamada <em>Notes.xcdatamodeld</em>, en la cual también verás incluido nuestro modelo por defecto.</p>


<p style="text-align: center;"><a href="http://www.thxou.com/wp-content/uploads/2013/11/Screen-Shot-2013-11-11-at-20.12.37.png"><img class="aligncenter size-full wp-image-2650" alt="Core Data Migration en ThXou" src="http://www.thxou.com/wp-content/uploads/2013/11/Screen-Shot-2013-11-11-at-20.12.37.png" width="256" height="90" /></a></p>


<p>Si nos fijamos, uno de los modelos aparece con un check de color verde. Esto quiere decir que es ese el modelo que estamos usando actualmente. Como queremos usar el nuevo modelo a partir de ahora, seleccionamos la carpeta contenedora <em>Notes.xcdatamodeld</em> y en panel<em> File Inspector</em> de la derecha, en el apartado<em> Model Version</em>, cambiamos la opción<em> Current</em> a<em> Notes 2</em>, que es nuestro nuevo modelo.</p>


<p>Vamos a hacer un par de modificaciones a <em>Notes 2</em>. Selecciona la entidad <strong>Note</strong> y añade un nuevo atributo llamado <strong>descriptionText</strong> de tipo <strong>String</strong>. Ahora vamos a renombrar el atributo <strong>backgroundColor</strong> a solo <strong>background</strong>.</p>


<p style="text-align: center;"><a href="http://www.thxou.com/wp-content/uploads/2013/11/Screen-Shot-2013-11-11-at-23.58.32.png"><img class="aligncenter  wp-image-2651" alt="Core Data Migration in ThXou" src="http://www.thxou.com/wp-content/uploads/2013/11/Screen-Shot-2013-11-11-at-23.58.32.png" width="526" height="134" /></a></p>


<p>Vamos a sanear cualquier error que pueda ocurrir después del cambio en el modelo de nuestra aplicación haciendo la migración, pero antes comentarte que al renombrar entidades o atributos es necesario definir el campo <em>Renaming ID</em>. Selecciona el atributo que hemos renombrado: <strong>background</strong>, y en el panel <em>Data Model Inspector</em> de la derecha, escribe en el campo <em>Renaming ID</em>, el nombre anterior del atributo, osea <strong>backgroundColor</strong> (Si no te acuerdas puedes mirar en la primera versión del modelo). Esto es obligatorio para cuando vayas a renombrar entidades o atributos.</p>


<p><a href="http://www.thxou.com/wp-content/uploads/2013/11/Screen-Shot-2013-11-12-at-00.06.30.png"><img class="aligncenter size-full wp-image-2652" alt="Core Data Migration" src="http://www.thxou.com/wp-content/uploads/2013/11/Screen-Shot-2013-11-12-at-00.06.30.png" width="254" height="83" /></a></p>


<h2>Haciendo la mudanza</h2>


<p>Lo que nos queda ahora es decirle a Core Data que haga la migración automática al iniciar la aplicación. Para esto nos tenemos que dirigir al <em>Core Data Stack</em> localizado en el fichero <em>AppDelegate.m</em>. En el vas a encontrar el método getter del Persistent Store Coordinator. Modifícalo con el siguiente código:</p>


<p>{% codeblock lang:objc %}
- (NSPersistentStoreCoordinator *)persistentStoreCoordinator
{
    if (<em>persistentStoreCoordinator != nil) {
        return </em>persistentStoreCoordinator;
    }</p>

<pre><code>NSURL *storeURL = [[self applicationDocumentsDirectory] URLByAppendingPathComponent:@"Notes.sqlite"];

NSError *error = nil;
_persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]];

// (2)
NSDictionary *options = @{NSMigratePersistentStoresAutomaticallyOption:@YES, NSInferMappingModelAutomaticallyOption:@YES};

if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:options error:&amp;error]) { // (1)
    NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
    abort();
}    

return _persistentStoreCoordinator;
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Dentro hay que modificar el método <code>addPersistentStoreWithType:configuration:URL:options:error:</code>(1), que es quien crea el almacenamiento para la app, en concreto el parámetro <code>options:</code>, a quien por defecto se le pasa <code>nil</code>, pero nosotros le asignamos el diccionario <code>options</code> con las keys que van a decirle a Core Data que lleve a cabo la migración automática (2).</p>


<p>Hasta este punto, ya puedes poner a correr la aplicación que estés migrando, verás que todo marcha sobre ruedas. Si no te salta ningún error ni ocurre ningún problema es porque la migración se ha realizado satisfactoriamente.</p>


<h2>Como se si mi app puede migrar automáticamente?</h2>


<p>Esto es un extra, por si se te plantea la pregunta para tus proyectos. Hemos visto que hay 2 formas de hacer la migración: automática (Fácil) y manual (difícil), como saber si mi app puede migrar automáticamente?. La respuesta está en preguntarle a la clase <code>NSMappingModel</code> si es capaz o no de crear el <strong>modelo de mapeo</strong> por si mismo. Esto lo hacemos con el método<code> inferredMappingModelForSourceModel:destinationModel:error:</code>:</p>


<p>{% codeblock lang:objc %}
- (BOOL)miModeloPuedeMigrar
{
    NSURL <em>modeloAntiguoURL = [[NSBundle mainBundle] URLForResource:@&ldquo;Notes&rdquo; withExtension:@&ldquo;momd&rdquo;];
    NSManagedObjectModel </em>modeloAntiguo = [[NSManagedObjectModel alloc] initWithContentsOfURL:modeloAntiguoURL];</p>

<pre><code>NSURL *modeloNuevoURL = [[NSBundle mainBundle] URLForResource:@"Notes 2" withExtension:@"momd"];
NSManagedObjectModel *modeloNuevo = [[NSManagedObjectModel alloc] initWithContentsOfURL:modeloNuevoURL];

NSMappingModel *modeloDeMapeo =
    [NSMappingModel inferredMappingModelForSourceModel:modeloAntiguo
                    destinationModel:modeloNuevo error:error];

// si Core Data es capaz de crear el modelo entonces 
// retornamos YES de lo contrario NO
if (!modeloDeMapeo)
{
    return NO;
}
return YES;
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Este método lo puedes usar en el método<code> application:didFinishLaunchingWithOptions:launchOptions</code> del <em>AppDelegate.m</em>, con un <code>NSLog</code> que te devuelva SI o NO dependiendo del valor de retorno del método <code>miModeloPuedeMigrar</code>.</p>




<h2>Conclución</h2>




<p>Este tutorial, como dije antes, es para cuando tienes que hacer ciertos cambios de los listados arriba. Si lo tuyo requiere algo diferente te va a tocar optar por aprender a realizar un mapeo personalizado.</p>




<p>Ten en cuenta cuando renombres entidades, que las clases modelo asociadas no se cambian, por lo que es algo de lo que te tienes que ocupar tu manualmente o usando la herramienta de refactorización de Xcode.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Literales en Objective-C]]></title>
    <link href="http://www.thxou.com/2013/03/18/literales-en-objective-c/"/>
    <updated>2013-03-18T19:04:13+01:00</updated>
    <id>http://www.thxou.com/2013/03/18/literales-en-objective-c</id>
    <content type="html"><![CDATA[<p>Los literales son simplemente unos valores que los programadores podemos escribir &#8220;tal cual&#8221; en el código. En Objective-C (y por lo tanto en C) ya conocemos algunos ejemplos de esto con los valores primitivos:</p>


<p>{% codeblock lang:objc %}
float altura = 23.5;
int piezas = 20;
{% endcodeblock %}</p>

<p>Estos son: un literal float y un literal int respectivamente. Estos literales son comunes en la mayoría de los lenguajes, no obstante Objective-C tiene sus propios literales a parte de los mencionados, concretamente los que están basados en objetos:</p>


<p>{% codeblock lang:objc %}
NSString *tarea = @”Buscar piso”;
{% endcodeblock %}</p>

<p>Claro, a simple vista podemos decir: Vaya chorrada, lo he usado mil veces!, pero detente un momento a pensar en el ahorro que implica en líneas de código el hecho de tenerlos: como escribirías un número &#8220;sin números&#8221;?, algo aún más terrorífico, plantearse escribir un string de miles de caracteres &#8220;sin strings&#8221;.</p>


<p>Dicho esto, es fácil darse cuenta de que los literales son una pieza fundamental de cualquier lenguaje por lo que nos ahorran, a parte de por los casos vistos, por la legibilidad en el código, así que vamos a conocer unos cuantos más pero específicos de Objective-C.</p>


<!-- more -->


<h2>La nueva moda en literales</h2>


<p>Hasta la salida de la versión 4.0 del compilador LLVM de Apple, Objective-C aún estaba un poco en pañales con respecto a lo que se refiere a literales. Mientras lenguajes basados en C como Perl o Python ya habían incluido literales para colecciones y más, Objective-C se resistía. Ahora eso ya es parte del pasado y vamos a ver cuales son las novedades en literales.</p>


<h3>Literales para colecciones</h3>


<h4>NSArray</h4>


<p>Clang, el front end de LLVM, introdujo la sintaxis <code>@[ ]</code> para definir arrays, en el cual solo se deben incluir objetos separados por comas. Ojo!, solo objetos, nada de tipos escalares. Así, lo que antes escribíamos así:</p>


<p>{% codeblock lang:objc %}
NSArray *ciudades = [NSArray arrayWithObjects:@&ldquo;Barcelona&rdquo;, @&ldquo;Lima&rdquo;, @&ldquo;Lyon&rdquo;, nil];
</code>
{% endcodeblock %}</p>

<p>Ahora nos queda así:</p>


<p>{% codeblock lang:objc %}
NSArray *ciudades = @[@”Barcelona”, @”Lima”, @”Lyon”];
{% endcodeblock %}</p>

<p>Al ser una característica del lenguaje ya no es necesario definir el centinela nil, de hecho si lo pones como valor, tu ordenador explotará, ya que se realiza una validación como para el método <code>[NSArrayarrayWithObjects:count:]</code>, en el que se requiere que ningún objeto sea nil. Por lo tanto si quieres pasar nil como valor tendrás que hacerlo con el objeto <code>[NSNull null]</code>, que es su equivalente.</p>


<h4>NSDictionary</h4>


<p>Aquí se introduce la sintaxis <code>@{ }</code>, similar a la de JSON o Javascript, pero con el @ característico de Objective-C. Esta sintaxis crea un diccionario de pares key-value, donde key tiene que ser un objeto que implemente el protocolo NSCopying (los string de toda la vida, vamos!) y value, como en el caso anterior, sólo pueden ser punteros a objetos Objective-C. Algo como:</p>


<p>{% codeblock lang:objc %}
NSDictionary *usuario = [NSDictionary dictionaryWithObjectsAndKeys:@”ThXou”, @”nombre”, @”Barcelona”, @”ubicacion”, nil];
{% endcodeblock %}</p>

<p>Ahora se escribiría:</p>


<p>{% codeblock lang:objc %}
NSDictionary *usuario = @{@”nombre” : @”ThXou”, @”ubicacion” : @”Barcelona”};
{% endcodeblock %}</p>

<p>Como en el caso de los arrays, aquí tampoco es necesaria la centinela nil.</p>


<h4>NSSet</h4>


<p>Pobre, se olvidaron de él. No se ha introducido nada para esta colección, no obstante con los literales de NSArray se puede aprovechar mucho para NSSet cuando necesitamos pasarlos como argumentos de los métodos inicializadores y métodos de conveniencia.</p>


<h2>Literales de NSNumber</h2>


<p>Para los que no sabéis cómo definir NSNumber, pues es una clase que nos permite envolver valores escalares (otros literales de tipo <code>int</code>, <code>bool</code>, <code>float</code>, etc) en objetos Objective-C.</p>


<p>Ahora, cualquier valor escalar que empiece por el símbolo ‘@’ devolverá un objeto NSNumber inicializado con ese valor. Esto ya lo veíamos con los strings de C. Cuando escribíamos algo como:</p>


<p>{% codeblock lang:objc %}
NSString *queja = @&ldquo;El billete de metro está caro&rdquo;;
{% endcodeblock %}</p>

<p>En realidad estamos convirtiendo un string en C a un objeto NSString con codificación UTF-8. Este literal está desde los inicios, pero para los otros valores escalares usábamos el método <code>numberWith<em>Tipo</em>:</code> para inicializar los objetos NSNumber. Ahora haremos:</p>


<p>{% codeblock lang:objc %}
NSNumber <em>bool = @NO; // es equivalente a [NSNumber numberWithBool:NO]
NSNumber </em>char = @&rsquo;d&#8217;; // es equivalente a [NSNumber numberWithChar:’d’]
NSNumber <em>unsignedInt = @23U; // es equivalente a [NSNumber numberWithUnsignedInt:23U]
NSNumber </em>int = @23; // es equivalente a [NSNumber numberWithInt:23]
NSNumber <em>long = @23L; // es equivalente a [NSNumber numberWithLong:23L]
NSNumber </em>longlong = @23LL; // es equivalente a [NSNumber numberWithLongLong:23LL]
NSNumber <em>float = @5.2303F; // es equivalente a [NSNumber numberWithFloat:5.2303F]
NSNumber </em>double = @2.2808; // es equivalente a [NSNumber numberWithDouble:2.2808]
{% endcodeblock %}</p>

<p>Me encanta este literal, por lo menos a mi me ayuda haciendo más legible el código, sobre todo cuando tengo que hacer una lectura rápida.</p>


<h2>Expresiones “en caja” (Boxed Expressions)</h2>


<p>Si la intuición os ha llevado a pensar: ¿Y qué pasa si hago <code>@2+2</code>, el compilador me lo pillará sin enfadarse?. Pues no, ya que hay una nueva sintaxis para esto y es envolver nuestras expresiones entre paréntesis: <code>@()</code>. Esto nos devolvería un objeto NSNumber inicializado con el resultado de la expresión que está entre estos. Y lo que antes hacíamos así:</p>


<p>{% codeblock lang:objc %}
NSNumber *piMedios = [NSNumber numberWithDouble:M_PI / 2];
{% endcodeblock %}</p>

<p>Ahora lo hacemos así:</p>


<p>{% codeblock lang:objc %}
NSNumber *piMedios = @(M_PI / 2);
{% endcodeblock %}</p>

<p>Mucho más claro y sencillo. Lo genial es que también funciona pasándole propiedades de algunos objetos Objective-C que devuelven valores escalares. Por ejemplo si tenías que guardar en Core Data el valor de un objeto UISwitch, lo hacíamos así:</p>


<p>{% codeblock lang:objc %}
tarea.completado = [NSNumber numberWithBool:mySwitch.on];
{% endcodeblock %}</p>

<p>Ahora también lo puedes hacer simplemente así:</p>


<p>{% codeblock lang:objc %}
tarea.completado = @(mySwitch.on);
{% endcodeblock %}</p>

<p>También funciona para enumeraciones:</p>


<p>{% codeblock lang:objc %}
typedef enum { Barcelona, Lima, Lyon } Ciudad;
NSNumber *ciudad = @(Lyon); // nos devolverá 1 y es equivalente a [NSNumber numberWithInt:((int)Lyon)]
{% endcodeblock %}</p>

<p>En este caso, para poder usar algún valor de la enumeración tenemos que envolverlo también como si se tratara de una expresión para poder usarlo como literal.</p>


<h2>Subíndices de objeto (Object Subscripting)</h2>


<p>Esta última tanda de literales de la que vamos a hablar suple una necesidad en mi que vengo deseando ver desde que dejé C++ para embarcarme en Objective-C, y tiene que ver con la forma de acceder y obtener datos de colecciones, concretamente de arrays y diccionarios.</p>


<h3>Subíndices para Arrays</h3>


<p>Para los arrays podemos usar un index para referirnos a la posición de un objeto dentro de ese array, tal como se hacía en C con valores escalares:</p>


<p>{% codeblock lang:objc %}
NSArray <em>ciudades = @[@&ldquo;Barcelona&rdquo;, @&ldquo;Lima&rdquo;, @&ldquo;Lyon&rdquo;];
NSString </em>ciudad = ciudades[2]; // ciudad = @&ldquo;Lyon&rdquo;
{% endcodeblock %}</p>

<p>Aquí se nos devuelve el elemento en la posición 2 que es <code>@"Lyon"</code>. Esto el compilador lo traduce por su equivalente en Objective-C: <code>[ciudades objectAtIndexedSubscript:2]</code>, lo cual es exactamente lo mismo que hacer: <code>[ciudades objectAtIndex:2]</code>.</p>


<p>De la misma forma, si tenemos un array mutable, entonces podemos hacer asignación directa de valores con esta misma sintaxis:</p>


<p>{% codeblock lang:objc %}
ciudades[1] = @&ldquo;Roma&rdquo;; // el array quedaría: @[@&ldquo;Barcelona&rdquo;, @&ldquo;Roma&rdquo;, @&ldquo;Lyon&rdquo;]
{% endcodeblock %}</p>

<p>El valor en la posición 1 es cambiado por el nuevo. Aquí el compilador hace una traducción al método <code>[ciudades setObject:@"Roma" atIndexedSubscript:1]</code></p>


<h3>Subíndices para diccionarios</h3>


<p>Para los diccionarios en vez de usar un index usamos keys para obtener los valores:</p>


<p>{% codeblock lang:objc %}
NSDictionary <em>usuario = @{@&ldquo;nombre&rdquo; : @&ldquo;ThXou&rdquo;, @&ldquo;ubicacion&rdquo; : @&ldquo;Barcelona&rdquo;};
NSString </em>ubicacion = usuario[@&ldquo;ubicacion&rdquo;]; // ubicacion = @&ldquo;Barcelona&rdquo;
{% endcodeblock %}</p>

<p>El compilador hace la traducción a <code>[usuario objectForKeyedSubscript:@"ubicacion"]</code>, el cual es a su vez equivalente a <code>[usuario objectForKey:@"ubicacion"]</code>.</p>


<p>Como en los arrays, pasa lo mismo para los diccionarios mutables y podemos reemplazar el valor correspondiente a la key que referenciemos:</p>


<p>{% codeblock lang:objc %}
usuario[@&ldquo;nombre&rdquo;] = @&ldquo;ThXou soy yo&rdquo;;
// el diccionario quedaría: @{@&ldquo;nombre&rdquo; : @&ldquo;ThXou soy yo&rdquo;, @&ldquo;ubicacion&rdquo; : @&ldquo;Barcelona&rdquo;}
{% endcodeblock %}</p>

<p>La traducción correspondiente es <code>[usuario setObject:@"ThXou soy yo" forKeyedSubscript:@"nombre"]</code>.</p>




<h2>Conclusión</h2>




<p>Esta nueva sintaxis como se puede observar, ayuda a que nuestro código sea más legible, a la par que nos ahorra tiempo escribiendo sus métodos equivalentes. Va a ser hora de pasarnos a la nueva moda, nunca es tarde aunque ya lleve unos cuantos meses rulando por internet. Es muy importante recordar pasar únicamente objetos al momento de crear objetos usando literales, como también no pasar nunca un <code>nil</code> como un valor.</p>


<h2>Fuentes:</h2>


<ul><li><a href="http://clang.llvm.org/docs/ObjectiveCLiterals.html">http://clang.llvm.org/docs/ObjectiveCLiterals.html</a></li><li><a href="http://www.mikeash.com/pyblog/friday-qa-2012-06-22-objective-c-literals.html">http://www.mikeash.com/pyblog/friday-qa-2012-06-22-objective-c-literals.html</a></li></ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSNotificationCenter Y Las Notificaciones]]></title>
    <link href="http://www.thxou.com/2013/02/21/nsnotificationcenter-y-las-notificaciones/"/>
    <updated>2013-02-21T14:12:51+01:00</updated>
    <id>http://www.thxou.com/2013/02/21/nsnotificationcenter-y-las-notificaciones</id>
    <content type="html"><![CDATA[<p>Vuelvo a la carga con los tutes sobre iOS después de un tiempo ausente por proyectos personales.</p>


<p>Esta vez os voy a hablar sobre otro tipo de notificaciones, diferentes a las notificaciones locales que <a href="http://www.thxou.com/2012/01/31/programando-notificaciones-locales-con-uilocalnotification/">vimos hace un tiempo</a>. Estas nuevas notificaciones básicamente encapsulan información acerca de algún tipo de evento. Hay objetos que registran estas notificaciones en lo que podemos llamar una &#8220;tabla de notificaciones&#8221;, esta tabla está administrada por un centro de notificaciones, que es un objeto <code>NSNotificationCenter</code>. Luego tenemos objetos que se registran como &#8220;Observadores&#8221; de estas notificaciones, de manera de que cuando una de estas notificaciones es lanzada, todos los observadores &#8220;se enteran&#8221; de esto y normalmente llevan a cabo alguna acción.</p>


<p>Podría parecer un poco chungo, pero no lo es para nada. Te pongo un ejemplo práctico. Imagina un portal de noticias. Los usuarios entran a este portal y pueden suscribirse a las categorías de noticias que ellos prefieran. Una vez sale una noticia relacionada con categoría a la que el usuario se ha suscrito, entonces le llega un correo electrónico avisándole que hay una nueva noticia, así el usuario puede decidir que hacer en ese momento. Pues bien, si hacemos una comparación sacamos que el usuario que se suscribe a las noticias es el &#8220;Observador&#8221;, el portal de noticias sería el &#8220;centro de notificaciones&#8221; (<code>NSNotificationCenter</code>) y el correo electrónico sería la notificación lanzada por el centro de notificaciones.</p>


<!-- more -->


<h2>A tocar código, que es lo que mola</h2>


<p>Últimamente escribir tanto texto sin una sola línea de código me da alergia, así que vamos a escribir unas cuantas líneas.</p>


<p>De toda la clase <code>NSNotificationCenter</code>, normalmente solo vamos a usar 4 métodos. El primero es para inicializar nuestro centro de notificaciones. Cada aplicación viene con uno por defecto y para acceder a el usamos un método de clase que lo que hace simplemente es crear un singleton:</p>


<p>{% codeblock lang:objc %}
NSNotificationCenter *center = [NSNotificationCenter defaultCenter];
{% endcodeblock %}</p>

<p>Ya tenemos nuestra instancia en el objeto <code>center</code>. El segundo método nos va a permitir registrar una notificación en el centro de notificaciones. A este método le pasamos el nombre de nuestra notificación y un objeto que es el que envía la notificación, normalmente <code>self</code>:</p>


<p>{% codeblock lang:objc %}
[center postNotificationName:@&ldquo;kTestNotification&rdquo; object:self];
{% endcodeblock %}</p>

<p>Se podrían separar estas notificaciones en 2 tipos: las personalizadas (como esta) y las que emite el sistema. En las que emite el sistema (por ejemplo cuando el dispositivo es girado o el teclado de un textField es mostrado), no necesitamos usar el método anterior ya que el sistema lo hace solo, nosotros solo tenemos que añadirnos como observadores de esas notificaciones y esperar, así que esto es lo que haremos ahora.</p>


<h2>Registrándonos como observadores</h2>


<p>Antes vimos el método para registrar una notificación llamada <code>kTestNotification</code> en el centro de notificaciones. Bien, ahora nos haremos &#8220;Observadores&#8221; de esta notificación para que cuando sea registrada (Osea, cuando sea ejecutado el método anterior), nosotros podamos llevar a cabo alguna acción en ese mismo instante:</p>


<p>{% codeblock lang:objc %}
[center addObserver:self
           selector:@selector(handleNotification:)
               name:@&ldquo;kTestNotification&rdquo;
             object:nil];
{% endcodeblock %}</p>

<p>El gustillo de este tipo de notificaciones para mi está en que, suponiendo el caso de que tu aplicación tenga 100 controladores, no importa en cual de estos 100 controladores registres la notificación, añadiendo tu clase como observador serás capaz de enterarte cuando sea registrada, en cualquier momento y en cualquier controlador.</p>


<p>Cuando el centro de notificaciones avisa a los observadores sobre una notificación lo hace de manera síncrona. Esto quiere decir que vas a tener que esperar primero a que todos los observadores reciban sus notificaciones antes de poder hacer algo. Esto se puede solucionar registrando las notificaciones de forma asíncrona usando <code>NSNotificationQueue</code> en vez de <code>NSNotificationCenter</code>, pero esto ya es otro tema del que hablaremos en otra oportunidad.</p>


<p>Al añadirnos como observadores también definimos un método a ejecutarse cuando la notificación sea registrada:</p>


<p>{% codeblock lang:objc %}
- (void)handleNotification:(NSNotification *)notification
{
    NSLog(@&ldquo;Hey tu!, se ha disparado la notificación!&rdquo;);
}
{% endcodeblock %}</p>

<p>Aquí simplemente mostramos por consola un texto, pero tu puedes usarlo para lo que quieras, cosas como mostrar un controlador, cerrar una conexión a Internet, etc.</p>


<h2>Liberando la memoria</h2>


<p>Lo único que nos queda ahora es liberar la memoria removiendo el observador que hemos asignado antes:</p>


<p>{% codeblock lang:objc %}
- (void)dealloc {
    // liberamos la memoria que ocupa el observador
    [[NSNotificationCenter defaultCenter] removeObserver:self];</p>

<pre><code>[super dealloc]; // quita esta línea si usas ARC
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Como vez, no estamos utilizando el objeto <code>center</code>, y a decir verdad para ahorrarte una innecesaria línea de código te recomiendo no crear un objeto <code>NSNotificationCenter</code>, sino usar la forma: <code>[[NSNotificationCenter defaultCenter] ...</code> , como en el código de arriba.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trabajando Con El Social Framework: SLRequest, Publicar en Twitter Y Obtener El Timeline]]></title>
    <link href="http://www.thxou.com/2012/09/20/trabajando-con-el-social-framework-de-ios-6-publicar-en-twitter-y-obtener-el-timeline/"/>
    <updated>2012-09-20T16:57:56+02:00</updated>
    <id>http://www.thxou.com/2012/09/20/trabajando-con-el-social-framework-de-ios-6-publicar-en-twitter-y-obtener-el-timeline</id>
    <content type="html"><![CDATA[<p style="text-align: center;"><a href="http://www.thxou.com/wp-content/uploads/2012/09/Screen-Shot-2012-09-20-at-14.23.29.png"><img class="size-full wp-image-2359" title="totweet-thxou.com" src="http://www.thxou.com/wp-content/uploads/2012/09/Screen-Shot-2012-09-20-at-14.23.29.png" alt="" width="319" height="479" /></a></p>


<p>Seguint amb els tutorials sobre iOS 6, avui ens toca Twittear (o com s&#8217;escrigui) i mostrar el nostre timeline de Twitter en una aplicació.</p>




<p>Abans quan volíem comunicar-nos amb Twitter i obtenir dades i actualitzar-los calia fer una connexió a través de OAuth amb uns tokens i secret-keys, això normalment es podia digerir millor usant algun framework o classe externa que servia d&#8217;interfície de connexió entre el client i el servei. Des de l&#8217;arribada del framework de Twitter i la integració amb iOS 5 les coses es van posar extraordinàriament més fàcils, això ens va permetre l&#8217;intercanvi de dades amb Twitter en tan sol pocs passos.</p>




<p>En el Social *Framework tenim una classe anomenada <code>SLRequest</code>, molt similar a <code>TWRequest</code> del framework de twitter. Aquesta classe encapsula les propietats d&#8217;una petició HTTP en mètodes fàcils d&#8217;utilitzar, amb els quals enviem peticions a Twitter per poder obtenir i actualitzar dades dels nostres comptes configurats en el dispositiu.</p>




<p>Bàsicament enviem una petició HTTP amb uns paràmetres que configuren el que volem dur a terme en el servei, si Twitter diu que no hi ha problema, rebem una resposta amb unes dades que hem de manipular i mostrar a l&#8217;usuari, en cas contrari rebem una informació d&#8217;error.</p>


<!-- more -->


<h2>Autenticant la petició</h2>


<p>Com els deia paràgrafs enrere, abans calia usar tokens i secret-keys per autenticar-nos en Twitter i així poder validar les nostres peticions. Amb el Social Framework fem el mateix però de forma automàtica, més transparent a l&#8217;usuari, i en certa forma al desenvolupador, ja que en cap moment hem de manipular tokens.</p>




<p>Des de iOS 5 tenim el Accounts Framework, el qual proveeix un sistema centralitzat de comptes d&#8217;usuari. A través de l&#8217;es emmagatzemen tots els comptes de Twitter (I d&#8217;altres serveis) configurades en el dispositiu: informació d&#8217;usuari i contrasenya i altra, això ens permet saltar-nos aquesta típica finestra d&#8217;inici de sessió sense haver de preocupar-nos per proveir un sistema per emmagatzemar nosaltres mateixos les credencials.</p>




<p>Hi ha poques coses que podem fer sense autenticació d&#8217;usuari, i obtenir el timeline és una d&#8217;elles. No obstant això, per fer que això funcioni amb qualsevol compte, centralitzarem totes les peticions en els comptes obtinguts de la base de dades de comptes del dispositiu. Comencem:</p>




<p>El primer serà importar els frameworks:</p>


<p>{% codeblock lang:objc %}</p>

<h1>import &lt;Accounts/Accounts.h></h1>

<h1>import &lt;Social/Social.h></h1>

<p>{% endcodeblock %}</p>

<p>Després fem la màgia d&#8217;obtenir els comptes del dispositiu amb el Accounts Framework:</p>


<p>{% codeblock lang:objc %}
ACAccountStore *accountStore = [[ACAccountStore alloc] init];</p>

<p>// creguem un objecte accountType especificant que solament volem obtenir els comptes de Twitter
ACAccountType *accountType = [accountStore accountTypeWithAccountTypeIdentifier:ACAccountTypeIdentifierTwitter];</p>

<p>[accountStore requestAccessToAccountsWithType:accountType
                                      options:nil
                                   completion:^(BOOL granted, NSError <em>error)
{
    if (granted)
    {
        // guardem els comptes de twitter en un array 
        NSArray </em>accountsArray = [accountStore accountsWithAccountType:accountType];
        // armem la petició aquí
    }
    else {
        NSLog(@&ldquo;Error no se pudo acceder a las cuentas: %@&rdquo;, [error localizedDescription]);
    }
}];
{% endcodeblock %}</p>

<p>El que fem aquí és crear una instància de la base de dades de comptes. Després a través de la classe <code>ACAccountType</code> diem que solament volem els comptes de Twitter, passant-li la constant  <code>ACAccountTypeIdentifierTwitter</code> com a argument en la inicialització. Tot seguit demanem accés a les comptes amb el mètode <code>requestAccessToAccountsWithType:options:completion:</code>. Aquest mètode té com a argument el bloc <code>completion:</code>, el qual és un handler (Un objecte &#8220;manipulador&#8221; per així dir-ho) en els paràmetres del qual és retornada la resposta del mètode. Si tot va bé emmagatzemem tots els comptes obtinguts en el array <code>accountsArray</code> o vam mostrar un error en cas contrari. Simple.</p>




<p>Recorda aquesta dinàmica d&#8217;executar un mètode i rebre una resposta per ser manipulada en un bloc, perquè ho veuràs molt sovint des d&#8217;ara.</p>


<h2>Construint la petició per obtenir el timeline</h2>


<p>Amb el Social Framework és definitivament molt més fàcil construir una petició HTTP. Sabem que està composta per:</p>


<ol>
    <li>Una URL que identifica l&#8217;operació que volem realitzar en el servei.</li>
    <li>Un mètode de petició, que pot ser GET, POST o DELETE.</li>
    <li>I uns paràmetres de configuració.</li>
</ol>


<p>El mètode <code>requestForServiceType:requestMethod:URL:parameters:</code> passa totes aquestes dades com els seus arguments i això ens permet crear la petició en tan sol una línia de codi si així ho desitgem.</p>




<p>El que nosaltres volem és obtenir el timeline, per tant necessitem anar a la <a title="Versión 1.1 de la API de Twitter" href="http://securelink.thxou.com/?https://dev.twitter.com/docs/api/1.1" target="_blank">documentació oficial</a> per veure el que hem d&#8217;usar. En entrar en l&#8217;enllaç i seleccionar l&#8217;operació de la qual volem veure els detalls (en aquest cas és: <code>GET</code> <code>statuses/home_timeline</code>), veurem en l&#8217;apartat <strong>Resourse Information</strong> certa informació molt important:
<p style="text-align: center;"><img class="size-full wp-image-2326 aligncenter" title="twitter-thxou.com" src="http://www.thxou.com/wp-content/uploads/2012/09/Screen-Shot-2012-09-11-at-17.08.28.png" alt="" width="249" height="392" /></p>
Tenim el mètode de la petició (GET), el format de resposta (JSON) i l&#8217;objecte de resposta (Tweets). Després està l&#8217;apartat <strong>Resource URL</strong> que és la URL que li passarem i l&#8217;apartat <strong>Parameters</strong>, que conté els paràmetres per configurar-la. Usant aquesta informació construïm la petició:</p>


<p>{% codeblock lang:objc %}
// guardem el compte
ACAccount *twitterAccount = [accountsArray objectAtIndex:0];
self.cuenta = twitterAccount;</p>

<p>// creguem la petició
NSURL *url = [NSURL URLWithString:@&ldquo;<a href="https://api.twitter.com/1.1/statuses/home_timeline.json">https://api.twitter.com/1.1/statuses/home_timeline.json</a>&rdquo;];</p>

<p>NSDictionary *parametros = [NSDictionary dictionaryWithObjectsAndKeys:
                                @&ldquo;25&rdquo;, @&ldquo;count&rdquo;, nil];</p>

<p>SLRequest *request = [SLRequest requestForServiceType:SLServiceTypeTwitter
                                        requestMethod:SLRequestMethodGET
                                                  URL:url
                                           parameters:parametros];</p>

<p>// associem el compte a la petició
[request setAccount:twitterAccount];
{% endcodeblock %}</p>

<p>Per motius de brevetat tan solament utilitzarem el primer compte de les quals hi ha en el array.</p>




<p>He creat la propietat <code>cuenta</code> de tipus <code>ACAccount</code>, en ella emmagatzemem aquest compte per posteriorment poder enviar-la al controlador des del qual publicarem un missatge d&#8217;estat (el que és un Tweet) al nostre timeline, això més endavant.</p>




<p>Com poden veure tenim un diccionari per als paràmetres. El meu solament té una key: <code>count</code>, aquesta ens permet limitar la quantitat de tweets que ens va a retornar el timeline que per defecte és 20, però jo l&#8217;he posat a 25. En la documentació de la API estan tots els paràmetres que podem usar per configurar la petició.</p>




<p>El següent és assignar-li a la propietat <code>account</code> de la nostra petició, el compte que hem triat del array i amb la qual volem treballar per mostrar el timeline i altres coses.</p>


<h2>Enviant la petició i manipulant els resultats</h2>


<p>Una vegada construïda la petició procedim a enviar-la. Per a això usem el mètode <code>performRequestWithHandler:</code> que envia la petició i recull els resultats en el seu únic argument. Est és al seu torn un bloc, el qual és executat una vegada estan disponibles les dades de la resposta.</p>


<p>{% codeblock lang:objc %}
// realitzem la petició especificant un mètode per manipular la resposta
[request performRequestWithHandler:^(NSData <em>responseData, NSHTTPURLResponse </em>urlResponse, NSError *error)
{
    if (responseData != nil)
    {
        self.tweets = [NSJSONSerialization JSONObjectWithData:responseData
                                                      options:kNilOptions
                                                        error:&amp;error];
    }
}];
{% endcodeblock %}</p>

<p>Aquest bloc té 3 paràmetres, el més important és <code>responseData</code>, perquè és el que va a contenir els tweets. Aquests tweets estan en format JSON com vam veure abans, per tant necessitem parsearlos i així passar-los a un format manipulable en Objective-C. Per fer això existeix la classe <code>NSJSONSerialization</code>, que agafa les dades en <code>NSData</code> (en aquest cas <code>responseData</code>), els parsea i retorna. Aquestes dades retornades els emmagatzemem en el array <code>tweets</code>, que a continuació usarem per mostrar-los a l&#8217;usuari.</p>


<p>{% blockquote %}
Pots aprendre més sobre com parsear dades en format JSON i la classe <code>NSJSONSerialization</code> en el nostre pràctic tutorial sobre el tema fent <a href="http://www.thxou.com/2012/09/11/parsear-y-crear-ficheros-en-formato-json-en-ios/"><strong>clic aquí</strong></a>.
{% endblockquote %}</p>

<h2>Mostrant els resultats</h2>


<p>Bé, ja tenim fet gairebé tot el treball, ara solament ens queda mostrar els resultats, i para això tenim l&#8217;objecte <code>tweetsTableView</code>. A causa que ja tenim tots els Tweets en un array, és relativament senzill mostrar-los en el tableView, per això anem directament a implementar els mètodes convenients:</p>


<p>{% codeblock lang:objc %}
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{
    return 1;
}</p>

<ul>
<li><p>(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
  return [self.tweets count];
}</p></li>
<li><p>(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath <em>)indexPath
{
  static NSString </em>CellIdentifier = @&ldquo;Cell&rdquo;;
  UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
  if (cell == nil)
  {
      cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier] autorelease];
  }</p>

<p>  NSDictionary *tweet = [self.tweets objectAtIndex:indexPath.row];</p>

<p>  cell.textLabel.text = [tweet objectForKey:@&ldquo;text&rdquo;];
  cell.detailTextLabel.text = [[tweet objectForKey:@&ldquo;user&rdquo;] objectForKey:@&ldquo;screen_name&rdquo;];</p>

<p>  // carreguem les imatges dels quals envien el tweet, de forma asíncrona
  dispatch_queue_t queue = dispatch_queue_create(&ldquo;com.thxou.totweet&rdquo;, NULL);
  dispatch_queue_t main = dispatch_get_main_queue();</p>

<p>  dispatch_async(queue, ^{
      NSURL <em>imageURL = [NSURL URLWithString:[[tweet objectForKey:@&ldquo;user&rdquo;] objectForKey:@&ldquo;profile_image_url&rdquo;]];
      NSData </em>imageData = [NSData dataWithContentsOfURL:imageURL];
      dispatch_async(main, ^{
          cell.imageView.image = [UIImage imageWithData:imageData];
      });
  });
  dispatch_release(queue);</p>

<p>  return cell;
}
{% endcodeblock %}</p></li>
</ul>


<p>Aquí hi ha algunes línies que els sonaran a xinès, no obstant això explicaré una mica per damunt que està succeint.</p>




<p>Al parsearse les dades aquests són emmagatzemats en el array <code>tweets</code>, però els tweets dins del, són emmagatzemats en forma de diccionaris, fàcilment recuperables usant la classe <code>NSDictionary</code>. Llavors recuperem cada camp d&#8217;aquest array en un diccionari que jo he anomenat <code>tweet</code> per fer-ho més identificable (en realitat això és el que representa). Com ja saben, accedim als valors d&#8217;un diccionari a través de keys, però quines són aquestes keys?, ens anem a la <a href="https://dev.twitter.com/docs/platform-objects/tweets">documentació oficial</a> i ho mirem allí. El que fem és simplement mostrar el text del tweet com a títol i el nom &#8220;del que tweetea&#8221; com subtitulo en cada cel·la.</p>




<p>Per mostrar la imatge el que fem és usar el <strong>GCD</strong> (Grand Central Dispatch) d&#8217;Apple. A grans trets explicar-los que la descàrrega de dades de la xarxa sempre deuria ser de forma asíncrona, això és perquè és un procés que triga una mica a dur-se a terme i per tant no pot fer-se en el mateix thread (fil) ja que podem bloquejar-ho, i això deixaria inutilitzable la interfície d&#8217;usuari fins que es completi el procés, cosa que pel bé dels nostres usuaris, no volem. Doncs aquest problema ho soluciona el <strong>GCD</strong>, fent que certs mètodes s&#8217;executin de forma asíncrona (en un altre fil o thread), d&#8217;aquesta forma evitem bloquejar la interfície d&#8217;usuari.</p>


<h2>Enviant un tweet</h2>


<p>Doncs fer això és una mica més del mateix. Jo he creat un nou controlador per fer això anomenat <code>EnviarTweetViewController</code>, el qual es mostra en una finestra modal i té un TextView i dos botons: un per enviar el tweet i un altre per cancel·lar l&#8217;operació.</p>




<p>El d&#8217;enviar el tweet executa el mètode <code>enviarTweet:</code>:</p>


<p>{% codeblock lang:objc %}
- (IBAction)enviarTweet:(id)sender
{
    // comprovem si el camp per escriure el tweet no està buit
    if (![self.tweet.text isEqualToString:@&ldquo;&rdquo;])
    {
        NSURL *url = [NSURL URLWithString:@&ldquo;<a href="https://api.twitter.com/1.1/statuses/update.json">https://api.twitter.com/1.1/statuses/update.json</a>&rdquo;];</p>

<pre><code>    NSDictionary *parametros = [NSDictionary dictionaryWithObjectsAndKeys:
                                self.tweet.text, @"status", nil];

    SLRequest *request = [SLRequest requestForServiceType:SLServiceTypeTwitter
                                            requestMethod:SLRequestMethodPOST
                                                      URL:url
                                               parameters:parametros];

    // assignem el compte que usarem per publicar el tweet
    [request setAccount:self.cuenta];

     [request performRequestWithHandler:^(NSData *responseData, NSHTTPURLResponse *urlResponse, NSError *error)
     {
         NSDictionary *resultado = [NSJSONSerialization JSONObjectWithData:responseData
                                                                   options:kNilOptions
                                                                     error:&amp;error];            
     }];

    [self cancelar:nil];
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Com podeu observar es fa exactament el mateix. Tan solament canvien els paràmetres, la URL i el mètode de la petició, i tot això el podem trobar en la documentació oficial.</p>




<p>A diferència de l&#8217;anterior, aquí no accedim a tots els comptes del dispositiu, sinó que simplement passem a aquest controlador el compte que hem obtingut abans, així ens assegurem que el compte que està seleccionada és des de la qual s&#8217;envia el tweet i sobre la qual es fan les operacions sol·licitades. No hi ha misteri.</p>


<h2>Conclusió</h2>


<p>El procediment per dur a terme totes aquestes accions en Twitter porten la mateixa estructura. Tan solament varien els paràmetres, la URL i el mètode de la petició. Pel que, si volem fer qualsevol cosa,  hem d&#8217;anar a la documentació i mirar el que necessitem. Després reemplaçar les dades que hem vist abans amb els nous, enviar la petició i mostrar a l&#8217;usuari les dades obtingudes. Així de fàcil és treballar amb el Social Framework.</p>




<p>Ara pots passar-te per la <a href="http://securelink.thxou.com/?https://developer.apple.com/library/ios/documentation/Social/Reference/SLRequest_Class/Reference/Reference.html#//apple_ref/doc/uid/TP40012234">documentació d&#8217;Apple</a> sobre aquest tema i també visitar el nostre tutorial sobre com parsear i manipular fitxers JSON de forma nativa i així estendre una mica més els teus coneixements.</p>


<p style="text-align: center;"><a href="http://securelink.thxou.com/?https://www.box.com/s/c0bb4xgyatv10t5nhvll"><img class="alignnone size-full wp-image-2134" title="boton-thxou.com" src="http://www.thxou.com/wp-content/uploads/2011/11/boton-thxou.png" alt="" width="256" height="52" /></a></p>

]]></content>
  </entry>
  
</feed>
